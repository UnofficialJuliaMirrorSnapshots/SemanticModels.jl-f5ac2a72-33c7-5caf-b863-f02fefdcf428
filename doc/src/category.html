<h1 id="a-category-for-models">A Category for Models</h1>
<p><span class="math inline"></span> Let <span class="math inline">ùíû</span> be the category of programs, where <span class="math inline"><em>O</em><em>b</em>(ùíû)</span> and <span class="math inline"><em>H</em><em>o</em><em>m</em>(<em>S</em>,‚ÄÜ<em>T</em>)={<em>f</em>‚ÄÖ‚à£‚ÄÖ<em>f</em>(:‚ÄÑ:‚ÄÑ<em>S</em>):‚ÄÑ:‚ÄÑ<em>T</em>}</span>. A model is a subcategory comprised of functions and types used in the code that implements that model. Then a model transformation is a function, <span class="math inline"><em>t</em></span>, on models <span class="math inline"><em>M</em></span> that induces a functor <span class="math inline"><em>F</em>‚ÄÑ:‚ÄÑ<em>t</em>(<em>M</em>)‚Üí<em>M</em></span>. We define the model transformation as function on models because you need to compute it going from the simple model to the more complex model, but the functor goes the other way, from the complex model to the simple model.</p>
<h2 id="properties-of-transformations">Properties of Transformations</h2>
<p>Model transformations respect composition.</p>
<p><em>Proof:</em> If <span class="math inline"><em>t</em><sub>1</sub>(<em>M</em>)=<em>M</em>‚Ä≤</span> there exists <span class="math inline"><em>F</em>‚ÄÑ:‚ÄÑ<em>M</em>‚Ä≤‚Üí<em>M</em></span> and <span class="math inline"><em>t</em><sub>2</sub>(<em>M</em>‚Ä≤)‚ÄÑ=‚ÄÑ<em>M</em>‚Ä≥</span> there exists <span class="math inline"><em>G</em>‚ÄÑ:‚ÄÑ<em>M</em>‚Ä≥‚Üí<em>M</em>‚Ä≤</span> then <span class="math inline"><em>t</em><sub>2</sub>‚ÄÖ‚àò‚ÄÖ<em>t</em><sub>1</sub></span> induces a functor <span class="math inline"><em>G</em>‚ÄÖ‚àò‚ÄÖ<em>F</em>‚ÄÑ:‚ÄÑ<em>M</em>‚Ä≥‚Üí<em>M</em></span> by the definition of functor.</p>
<h2 id="examples">Examples</h2>
<p>A simple model of gravity can be represented. Everyone knows the formula for the force of gravity, the sum of the masses divided by the double of the radius between them</p>
<p><span class="math inline">$F = G \frac{m_1 + m_2}{2r}$</span></p>
<p>Oh wait, that isn‚Äôt right, it has that structure, but is it the sum or the product? And is twice the radius or the square of the radius?</p>
<p>A model transformation can recover the right model for us. The following figure show <span class="math inline"><em>M</em></span> on the left and <span class="math inline"><em>M</em>‚Ä≤</span> on the right. The functor between them is shown using color.</p>
<figure>
<embed src="img/cd/gravity.pdf" /><figcaption>gravity diagram</figcaption>
</figure>
<p>The functor from <span class="math inline"><em>M</em>‚Ä≤</span> to <span class="math inline"><em>M</em></span> tells us how to transform <span class="math inline"><em>M</em>‚Ä≤</span> back into <span class="math inline"><em>M</em></span>. We see that the only think that changed is <span class="math inline">√ó</span> becomes <span class="math inline">+</span> and <span class="math inline"><em>s</em><em>q</em><em>r</em></span> becomes <span class="math inline"><em>d</em><em>b</em><em>l</em></span>. This is exactly the way a programmer would describe the difference between these two models.</p>
<p>We can see the notion of a fully faithful functor indicating that these models have the same structure. The functions in these two programs are in 1-1 correspondence. The notion of fully faithful functors says that for every pair of types <span class="math inline"><em>S</em>,‚ÄÜ<em>T</em></span> <span class="math inline"><em>F</em></span> maps <span class="math inline"><em>H</em><em>o</em><em>m</em><sub><em>M</em>‚Ä≤</sub>(<em>S</em>,‚ÄÜ<em>T</em>)</span> to <span class="math inline"><em>H</em><em>o</em><em>m</em><sub><em>M</em></sub>(<em>F</em>(<em>S</em>),<em>F</em>(<em>T</em>))</span> with a 1-1 function. For this case <span class="math inline"><em>F</em>(<em>S</em>)=<em>S</em></span> for all types. So this reduces to <span class="math inline"><em>H</em><em>o</em><em>m</em><sub><em>M</em>‚Ä≤</sub>(<em>S</em>,‚ÄÜ<em>T</em>)‚Üí<em>H</em><em>o</em><em>m</em><sub><em>M</em></sub>(<em>S</em>,‚ÄÜ<em>T</em>)</span> with a 1-1 function. Based on the sizes of the <span class="math inline"><em>H</em><em>o</em><em>m</em></span> sets, we see that there are only 4 possible fully faithful functors between these two models. The most obvious one is the one shown with color.</p>
<h3 id="isomorphism-is-too-strict">Isomorphism is too strict</h3>
<p>You might think that since these diagrams look like graphs and the functors look like graph homomorphism, that graph isomorphism is a good definition of ‚Äúmodels with the same structure‚Äù. But this is two strict.</p>
<p>In the following example the type graphs are not isomorphic, but there is a fully faithful functor between the model categories. <embed src="img/cd/modelfunctor1.pdf" /></p>
<h2 id="a-category-of-models">A category of models</h2>

<p>Let <span class="math inline">‚Ñ≥‚Ñ¥ùíπ</span> represent the category of models under transformation. <span class="math inline"><em>O</em><em>b</em>(‚Ñ≥‚Ñ¥ùíπ)</span> is the set of models and <span class="math inline"><em>H</em><em>o</em><em>m</em><sub>‚Ñ≥‚Ñ¥ùíπ</sub>(<em>M</em>‚Ä≤,<em>M</em>)</span> is the set of functors from <span class="math inline"><em>M</em>‚Ä≤</span> to M (ie. transformations from <span class="math inline"><em>M</em></span> to <span class="math inline"><em>M</em>‚Ä≤</span>).</p>
<h2 id="perspective-on-model-selection">Perspective on Model Selection</h2>
<p>Given an initial model <span class="math inline"><em>M</em></span> a set of morphisms in <span class="math inline">‚à™<sub><em>x</em></sub><em>H</em><em>o</em><em>m</em><sub>‚Ñ≥‚Ñ¥ùíπ</sub>(<em>M</em>,‚ÄÜ<em>x</em>)</span> we want to pick the <span class="math inline"><em>m</em></span> that minisimizes some function <span class="math inline">‚Ñì(<em>m</em>)</span> which is the loss between the data and the model <span class="math inline"><em>m</em></span>. Suppose that <span class="math inline"><em>T</em>‚ÄÑ=‚ÄÑ‚ü®<em>T</em><sub><em>i</em></sub>‚ü©</span> is the set of transformations generated by <span class="math inline">{<em>T</em><sub><em>i</em></sub>‚ÄÖ‚à£‚ÄÖ<em>i</em>‚ÄÑ‚àà‚ÄÑ‚Ñê}</span>. We want to derive model selection algorithms that work for any <span class="math inline"><em>M</em>,‚ÄÜ‚Ñì,‚ÄÜ<em>T</em></span>.</p>
<p>These algorithms will exploit the algebra of the transformation set, for example if the set of transformations is just a compositional monoid then the only option is to enumerate the tree of possible transformations <span class="math inline">(<em>L</em><em>i</em><em>s</em><em>t</em>(<em>T</em>),‚ÄÖ+‚ÄÖ+,‚ÄÜ[])</span> and pick the one that minimizes the loss. If the transformations have a stronger structure, such as forming a ring, and that structure is compatible with respect to the loss function, we should be able to find algorithms that exploit that structure.</p>
