A Category for Models
=====================

[]{.math .inline} Let [ùíû]{.math .inline} be the category of programs,
where [*Ob*(ùíû)]{.math .inline} and
[*Hom*(*S*,‚ÄÜ*T*)={*f*‚ÄÖ‚à£‚ÄÖ*f*(:‚ÄÑ:‚ÄÑ*S*):‚ÄÑ:‚ÄÑ*T*}]{.math .inline}. A model is
a subcategory comprised of functions and types used in the code that
implements that model. Then a model transformation is a function,
[*t*]{.math .inline}, on models [*M*]{.math .inline} that induces a
functor [*F*‚ÄÑ:‚ÄÑ*t*(*M*)‚Üí*M*]{.math .inline}. We define the model
transformation as function on models because you need to compute it
going from the simple model to the more complex model, but the functor
goes the other way, from the complex model to the simple model.

Properties of Transformations
-----------------------------

Model transformations respect composition.

*Proof:* If [*t*~1~(*M*)=*M*‚Ä≤]{.math .inline} there exists
[*F*‚ÄÑ:‚ÄÑ*M*‚Ä≤‚Üí*M*]{.math .inline} and [*t*~2~(*M*‚Ä≤)‚ÄÑ=‚ÄÑ*M*‚Ä≥]{.math .inline}
there exists [*G*‚ÄÑ:‚ÄÑ*M*‚Ä≥‚Üí*M*‚Ä≤]{.math .inline} then
[*t*~2~‚ÄÖ‚àò‚ÄÖ*t*~1~]{.math .inline} induces a functor
[*G*‚ÄÖ‚àò‚ÄÖ*F*‚ÄÑ:‚ÄÑ*M*‚Ä≥‚Üí*M*]{.math .inline} by the definition of functor.

Examples
--------

A simple model of gravity can be represented. Everyone knows the formula
for the force of gravity, the sum of the masses divided by the double of
the radius between them

[\$F = G \\frac{m\_1 + m\_2}{2r}\$]{.math .inline}

Oh wait, that isn't right, it has that structure, but is it the sum or
the product? And is twice the radius or the square of the radius?

A model transformation can recover the right model for us. The following
figure show [*M*]{.math .inline} on the left and [*M*‚Ä≤]{.math .inline}
on the right. The functor between them is shown using color.

gravity diagram

The functor from [*M*‚Ä≤]{.math .inline} to [*M*]{.math .inline} tells us
how to transform [*M*‚Ä≤]{.math .inline} back into [*M*]{.math .inline}.
We see that the only think that changed is [√ó]{.math .inline} becomes
[+]{.math .inline} and [*sqr*]{.math .inline} becomes [*dbl*]{.math
.inline}. This is exactly the way a programmer would describe the
difference between these two models.

We can see the notion of a fully faithful functor indicating that these
models have the same structure. The functions in these two programs are
in 1-1 correspondence. The notion of fully faithful functors says that
for every pair of types [*S*,‚ÄÜ*T*]{.math .inline} [*F*]{.math .inline}
maps [*Hom*~*M*‚Ä≤~(*S*,‚ÄÜ*T*)]{.math .inline} to
[*Hom*~*M*~(*F*(*S*),*F*(*T*))]{.math .inline} with a 1-1 function. For
this case [*F*(*S*)=*S*]{.math .inline} for all types. So this reduces
to [*Hom*~*M*‚Ä≤~(*S*,‚ÄÜ*T*)‚Üí*Hom*~*M*~(*S*,‚ÄÜ*T*)]{.math .inline} with a
1-1 function. Based on the sizes of the [*Hom*]{.math .inline} sets, we
see that there are only 4 possible fully faithful functors between these
two models. The most obvious one is the one shown with color.

### Isomorphism is too strict

You might think that since these diagrams look like graphs and the
functors look like graph homomorphism, that graph isomorphism is a good
definition of "models with the same structure". But this is two strict.

In the following example the type graphs are not isomorphic, but there
is a fully faithful functor between the model categories.

A category of models
--------------------

Let [‚Ñ≥‚Ñ¥ùíπ]{.math .inline} represent the category of models under
transformation. [*Ob*(‚Ñ≥‚Ñ¥ùíπ)]{.math .inline} is the set of models and
[*Hom*~‚Ñ≥‚Ñ¥ùíπ~(*M*‚Ä≤,*M*)]{.math .inline} is the set of functors from
[*M*‚Ä≤]{.math .inline} to M (ie. transformations from [*M*]{.math
.inline} to [*M*‚Ä≤]{.math .inline}).

Perspective on Model Selection
------------------------------

Given an initial model [*M*]{.math .inline} a set of morphisms in
[‚à™~*x*~*Hom*~‚Ñ≥‚Ñ¥ùíπ~(*M*,‚ÄÜ*x*)]{.math .inline} we want to pick the
[*m*]{.math .inline} that minisimizes some function [‚Ñì(*m*)]{.math
.inline} which is the loss between the data and the model [*m*]{.math
.inline}. Suppose that [*T*‚ÄÑ=‚ÄÑ‚ü®*T*~*i*~‚ü©]{.math .inline} is the set of
transformations generated by [{*T*~*i*~‚ÄÖ‚à£‚ÄÖ*i*‚ÄÑ‚àà‚ÄÑ‚Ñê}]{.math .inline}. We
want to derive model selection algorithms that work for any
[*M*,‚ÄÜ‚Ñì,‚ÄÜ*T*]{.math .inline}.

These algorithms will exploit the algebra of the transformation set, for
example if the set of transformations is just a compositional monoid
then the only option is to enumerate the tree of possible
transformations [(*List*(*T*),‚ÄÖ+‚ÄÖ+,‚ÄÜ\[\])]{.math .inline} and pick the
one that minimizes the loss. If the transformations have a stronger
structure, such as forming a ring, and that structure is compatible with
respect to the loss function, we should be able to find algorithms that
exploit that structure.
